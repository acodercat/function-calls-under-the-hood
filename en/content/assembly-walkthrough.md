# C Function Stack Frame Example

> We will compile a piece of C code containing function calls into assembly and analyze the complete lifecycle of the function stack frame step by step.



Here is the C code:

```c
long callee(long arg1, long arg2, long arg3, long arg4, long arg5, long arg6, long arg7, long arg8) {
    return arg7 + arg8;
}

int main() {
    long a = 7;
    long b = 8;
    callee(1, 2, 3, 4 ,5 ,6, a, b);
    return 0;
}
```

The `callee` function has 8 parameters `arg1~arg8` and returns the sum of `arg7` and `arg8`. Since our code runs on an `X64` machine, `arg1~arg6` will be passed through registers, while `arg7` and `arg8` are passed through the stack. `main` defines two local variables `a` and `b`, and calls `callee`, where local variables `a,b` correspond to `callee`'s `arg7,arg8`.

Compiling the C code above into assembly and removing other instructions generated by the compiler that are not relevant to our stack frame analysis, we get the following instructions (the generated assembly instructions may vary depending on the compiler version and operating system; here we use `gcc9.0` and `ubuntu 20.04 x-64`):

```ASM
callee:
    pushq	%rbp
    movq	%rsp, %rbp
    movq	%rdi, -8(%rbp)
    movq	%rsi, -16(%rbp)
    movq	%rdx, -24(%rbp)
    movq	%rcx, -32(%rbp)
    movq	%r8, -40(%rbp)
    movq	%r9, -48(%rbp)
    movq	16(%rbp), %rdx
    movq	24(%rbp), %rax
    addq	%rdx, %rax
    popq	%rbp
    ret
main:
    pushq	%rbp
    movq	%rsp, %rbp
    subq	$16, %rsp
    movq	$7, -16(%rbp)
    movq	$8, -8(%rbp)
    pushq	-8(%rbp)
    pushq	-16(%rbp)
    movl	$6, %r9d
    movl	$5, %r8d
    movl	$4, %ecx
    movl	$3, %edx
    movl	$2, %esi
    movl	$1, %edi
    call	callee
    addq	$16, %rsp
    movl	$0, %eax
    leave
    ret
```

The `callee:` and `main:` in the instructions are labels for the instructions below them, which can be understood as function names.

**In `X64`, the `stack pointer` and `base pointer` are called `rsp` and `rbp` respectively.**

Let's analyze the impact of these instructions on the stack step by step. First, the first two instructions of `main`:

```asm
pushq	%rbp
movq	%rsp, %rbp
```

Actually, the `main` function is called by a system function called `_start`, so the first instruction pushes the `caller` _start's `base pointer` onto the stack to save it, and the second instruction moves the `base pointer` to point to the same location as the `stack pointer`.

Stack change process (initially our `stack pointer` and `base pointer` point to `_start`'s stack frame, which is not drawn here so they are not labeled):

![](../../images/stack22.png)



Initialize local variables and prepare the last two parameters for `callee`:

```asm
subq	$16, %rsp
movq	$7, -16(%rbp)
movq	$8, -8(%rbp)
pushq	-8(%rbp)
pushq	-16(%rbp)
```

The `subq` in the first instruction is a subtraction instruction, used here to subtract 16 from the `stack pointer`, moving it toward lower addresses to allocate 16 bytes of space for local variables `a,b` (long occupies 8 bytes).

The `movq` in instructions 2-3 is a data movement instruction, which assigns values to `a,b` by offsetting from the `base pointer`. For example, `movq $7, -16(%rbp)` means putting 7 into memory at offset -16 relative to the `base pointer`. In the diagram below, you can see that after these two instructions execute, variables `a,b` are placed at positions `-16` and `-8`.

Instructions 4-5 copy the values of `a,b` from the stack frame and push them, preparing the last 2 parameters `arg7` and `arg8` for function `callee`.

Stack change process (the numbers on the right side of the diagram represent offsets relative to the `base pointer`, each cell is 8 bytes; since stack space grows toward lower addresses, offsets above the `base pointer` are negative):

![](../../images/stack23.png)





Store the first 6 parameters `arg1~arg6` of `callee` in registers:

```asm
movl	$6, %r9d
movl	$5, %r8d
movl	$4, %ecx
movl	$3, %edx
movl	$2, %esi
movl	$1, %edi
```


Start calling `callee`:

```asm
call	callee
```

This instruction corresponds to two operations: first, push the address of the instruction below it, which is the address of `addq $16, %rsp` (the return address), onto the stack, then modify the `Program Counter` (PC) to the address of `callee`'s first instruction. Finally, the CPU starts executing from `callee`.

The stack after this instruction executes:

![](../../images/stack24.png)

Now the CPU starts executing from `callee`:

```asm
pushq	%rbp
movq	%rsp, %rbp
```

First push `main`'s stack frame's `base pointer`, then move the `base pointer` to point to the same location as the `stack pointer`. At this point, `callee`'s stack frame is created:

The second instruction changes the `base pointer`, so the offsets relative to the `base pointer` in the right diagram also need to change (since stack space grows toward lower addresses, offsets below the `base pointer` are positive):

![](../../images/stack25.png)



Copy the first 6 parameters to the stack frame:

```asm
movq	%rdi, -8(%rbp)
movq	%rsi, -16(%rbp)
movq	%rdx, -24(%rbp)
movq	%rcx, -32(%rbp)
movq	%r8, -40(%rbp)
movq	%r9, -48(%rbp)
```

These 6 registers `rdi,rsi,rdx,rcx,r8,r9` contain `callee`'s first 6 parameters, which are now copied from registers to `callee`'s own stack frame. The compiler does this for several reasons: (1) The function body may need to get the address of a parameter (like `&arg1`), but registers don't have memory addresses; (2) Registers are limited, and complex functions need to free up registers for other computations; (3) Compiler optimization is not enabled here (`-O0`); with optimization enabled, these redundant operations would be eliminated.

Stack structure after execution:

![](../../images/stack26.png)

Something strange happens here - the `stack pointer` doesn't continue moving toward lower addresses to point to the top of the stack. This is actually related to the **Red Zone** concept in the X64 ABI.

> **Red Zone**: In the X64 System V ABI, the 128 bytes below the stack pointer are called the "red zone." Leaf functions (functions that don't call other functions) can use this area to store temporary data without moving the stack pointer. This saves `subq` and `addq` instructions, improving efficiency. However, if a function calls other functions, the red zone data may be overwritten, so only leaf functions can use the red zone.

Since `callee` doesn't call any other functions (it's a leaf function), it can directly use the red zone without modifying the `stack pointer`.

Execute the addition:

```asm
movq    16(%rbp), %rdx
movq	24(%rbp), %rax
addq	%rdx, %rax
```

Add `arg7` and `arg8` together, then put the result in the `rax` register. The `main` function can access the `rax` register to get the return value, thus achieving function return value passing.



Return to `main`:

```asm
popq	%rbp
ret
```

Restore the `base pointer` and jump to the return address to continue execution.

Stack change process:

![](../../images/stack27.png)





Return to `_start`:

```asm
addq	$16, %rsp
movl	$0, %eax
leave
ret
```

The `addq` in the first instruction is an addition instruction, used here to add 16 to the `stack pointer`, moving it toward higher addresses to release the memory for `arg7,arg8`. From this step, we can see that parameters' stack memory is released immediately after the function finishes executing.

The second instruction puts `main`'s return value 0 into the `eax` register.

The third instruction `leave` implicitly performs two operations, equivalent to these two instructions:

```asm
movq	%rbp, %rsp
popq	%rbp
```

First modify the `stack pointer` to point to the same location as the `base pointer` - this step mainly releases local space - then restore the `base pointer`. At this point, the `stack pointer` and `base pointer` now point to `_start`'s stack frame.

Here we notice that `main` and `callee` have different return processes. This is because `callee` didn't use the `subq` instruction to modify the `stack pointer` to allocate local space at the beginning, so it doesn't need to use the `leave` instruction to restore the `stack pointer` when returning. From this, we can conclude: functions that call other functions and functions that don't call other functions have slightly different return processes.

The fourth instruction `ret` makes the CPU return to `_start` to continue execution, and everything returns to calm.

Stack change process:

![](../../images/stack28.png)



**Finally, we notice that data is still preserved in the stack, because releasing stack space doesn't modify the data inside - it just moves the `stack pointer` and `base pointer`.**
