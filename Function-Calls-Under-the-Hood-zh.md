# Function Calls Under the Hood

**当你调用一个函数时，究竟发生了什么？**

从汇编视角深入理解函数调用原理。

---

## 关于本指南

本文通过详细的示意图，展示函数调用时栈的完整变化过程。结合 x86-64 平台的具体示例，分析 C 代码如何转换为汇编指令，帮助你理解底层机制。最后通过实践案例，探索栈帧的有趣行为。

### 你将学到

- 函数间如何转移控制
- 函数间如何传递数据
- 栈帧的创建与销毁
- C/C++ 数组越界的危害
- 为什么内联函数效率更高
- 为什么循环优于递归
- 为什么静态变量在函数返回后不会被释放
- 什么是栈溢出攻击及其原理

### 补充说明

本文未涉及`内存对齐`概念，因为它不属于函数调用的范畴。在构造示例时，我刻意避免了编译器为内存对齐生成额外指令的情况。如果你对内存对齐感兴趣，可以通过网络资源进一步了解。

### 参考资料

- 书籍：
  - 《深入理解计算机系统》（第三版）
  - 《汇编语言》（王爽 第三版）

- 公开课：
  - [《编程范式》（斯坦福 CS107）](https://see.stanford.edu/course/cs107)

### 致谢

文中所有图片均使用 [Excalidraw](https://excalidraw.com/) 绘制。

---

## 目录

1. [第一章：前置知识](#第一章前置知识)
2. [第二章：内存中的栈](#第二章内存中的栈)
3. [第三章：控制转移](#第三章控制转移)
4. [第四章：数据传递](#第四章数据传递)
5. [第五章：寄存器的保存与恢复](#第五章寄存器的保存与恢复)
6. [第六章：局部变量的存储](#第六章局部变量的存储)
7. [第七章：函数栈帧](#第七章函数栈帧)
8. [第八章：C语言函数栈帧实例](#第八章c语言函数栈帧实例)
9. [第九章：栈帧内存复用](#第九章栈帧内存复用)
10. [第十章：手动修改栈帧数据](#第十章手动修改栈帧数据)
11. [第十一章：总结](#第十一章总结)

---

# 第一章：前置知识

> 这里先对一些基础知识做一些简单说明，以方便后面阅读。

## 1.1 函数定义

> 计算机中的函数（有时也被称为过程或方法）提供了一种`封装代码`的方式，用一组指定的参数和可选的返回值实现了某种功能。然后可以在程序不同的地方调用这个函数。`调用者`可以向`被调用者`传递一组参数，`被调用者`执行完后可以向`调用者`返回执行结果。

在进行函数调用时，计算机底层需要提供如下机制：

- **控制转移**

  需要把`控制转移`到被调用函数，然后当被调用函数`执行完毕`后再回到原来的位置继续执行。

- **数据传递**

  调用者可以向被调用者`传递参数`，同时被调用者也可以向调用者`返回数据`。

- **内存分配与释放**

  在开始时，可能需要为被调用者分配`局部内存`来存储`局部变量`，在函数返回时必须对这些内存进行释放。

## 1.2 栈

栈是一种数据结构，可以把它理解为一个容纳数据的容器，它具有`先进后出`（也等价于后进先出）的特性，也就是先进入`栈`的数据，最后才能出来。也可以把它想象成你桌面的一摞书，每次只能取最上面的一本书，新到来的书只能放在最上面。或者也可以把它想像成你身上的衣服，最先穿的衣服，最后才能脱掉。因此对于`栈`来说就有两个重要的操作即`压栈`（push）和`出栈`（pop）。`压栈`表示从栈的顶部新增一条数据，`出栈`表示把栈顶部的数据取出来。栈这种数据结构具有`记忆功能`，也就是出栈的值永远是最近被压入且仍然在栈中的值。

## 1.3 内存

内存是计算机中一组`连续的`存储区域，这块区域被计算机组织成由无数个连续的以`字节`（8个二进制位）大小为单元的集合。并且为每个`内存单元`提供一个唯一的`内存地址`用于计算机方便对某个内存单元进行访问，也就是每个字节都会有一个`内存地址`。例如第一个字节的地址是0，和它挨着的第二个字节地址就是1，以此类推。我们把内存地址较大的一端称作`高地址`，内存地址较小的一端称作`低地址`。

## 1.4 汇编指令

`汇编语言`是直接工作在机器之上的语言。计算机只能识别由0，1组成的二进制序列，所以CPU也只能执行由0，1所组成的`机器指令`。汇编语言是机器指令的`助忆符`，它可以方便人类辨别和记忆。每一条汇编指令会对应一条或多条机器指令。本文中会使用一种类似于C语言的伪代码来描述栈的变化过程。

## 1.5 寄存器

`CPU`的内部有一组存储器用来存放一些较小的临时数据，称这组存储器为`寄存器`，寄存器的访问速度比内存快很多，通过快速地访问数据来加速计算机程序的运行。CPU想要访问内存中的数据就必须把内存中的数据转移到寄存器中然后CPU再从寄存器中读取。寄存器位于存储器层次结构的最顶端，也是CPU可以读写的最快的存储器。每个寄存器有专门的名字，不同的寄存器用途也不一样。

---

# 第二章：内存中的栈

> 操作系统会为`进程`（正在运行的应用程序）分配`内存空间`用于存放程序在执行过程中需要的代码和数据。根据内存的使用方式不同，会把内存划分成几个具有不同功能的区域。其中一块区域叫做`堆栈`（在本文中特指栈，英文为 stack），它和数据结构中的栈一样具有`后进先出`的性质。`堆栈`用于记录函数在调用过程中产生的信息，比如函数局部变量和参数等信息。本文后面提到的`栈`均指的是内存中的`堆栈`。

CPU提供了对栈内存进行`压栈`（push）和`出栈`（pop）的指令，同时还有一个叫做`栈指针`（sp）的寄存器用来保存`栈顶`位置的`内存地址`。`栈内存`是从`高地址`向`低地址`空间发展，这一点跟正常的思维习惯有点不一样，也就是说当你向`栈`中`push`一个新的数据时，栈的地址会变小。

**为了方便表示本文后面的所有栈结构图中的每个格子都是8个字节 ，同时我们也假设push和pop指令每次操作8个字节**。

下图是一个大小为80个字节（图中每个格子是8个字节）的`栈`，地址范围是0~79。`栈指针`指向栈顶的位置：

![](images/stack1.png)

**后面提到的指令均是类似于C语言的伪代码，只是用来描述栈的变化过程。**

## 2.1 压栈

压栈时把`栈指针`往`低地址`移动也就是减小栈指针，然后把数据写入到以`栈指针`开始的内存中。

例如要把数值`123`压入到栈中，对应的指令就是：

```c
push(123);
```

它的效果等价于下面这两条指令：

```c
sp = sp - 8;
*sp = 123;
```

由于我们假设push指令每次操作8个字节，所以第1条指令先把`sp`（栈指针）向低地址移动8个字节。然后第2条指令再把数据写入到以`sp`开始的那8个字节的内存中。`*sp`表示的是`栈指针`所指向的那块内存空间，而不是`栈指针`本身。

栈变化过程：

![](images/stack15.png)

## 2.2 出栈

出栈时先取出以`栈指针`开头的8个字节（我们假设pop每次操作8个字节）的数据，再把`栈指针`向高地址移动8个字节也就是增加栈指针。

把压栈例子中`栈顶`的数据出栈至变量`rax`中，对应的指令：

```c
pop(rax);
```

它的效果等价于下面这两条指令：

```c
rax = *sp;
sp = sp + 8;
```

先把以`栈指针`开始的8个字节的数据放入变量`rax`中，由于压栈例子中压入的是123，所以此时出栈的数据也是123，最后把`栈指针`向高地址移动8个字节。

栈变化过程：

![](images/stack16.png)

---

# 第三章：控制转移

> 在进行函数调用时，需要把`控制转移`到`被调用函数`，然后当被调用函数执行完毕后再回到原来的位置继续执行。

我们已经知道操作系统会把进程的`内存空间`划分成几个具有不同功能的区域。除了前面提到的`堆栈段`（也被称为栈）以外，还有一个叫做`代码段`的区域，它用来存放该进程运行中所需要的机器指令。CPU在读取指令的过程中，它需要知道当前应该执行哪一条指令。因此CPU提供了一个叫做`程序计数器`（PC）的寄存器，用它来存放CPU当前要执行的指令在`代码段`中的内存地址。

由于CPU在执行时都是从`PC`中获取指令地址，所以当发生函数调用时可以把`PC`修改成`被调用者`指令的`起始地址`，这样一来CPU就会从`被调用者`开始执行。当`被调用者`执行完之后，为了让CPU从原来的位置继续执行。可以再次修改`PC`为在发生调用时的`下一条指令`的地址，这个地址被称为函数的`返回地址`。

考虑有如下C语言代码：

```c
void Q() {
    printf("this is Q.");
    return;
}

void P() {
    printf("readying to call Q.");
    Q();
    return;
}
```

我们假设代码的`行号`就是`指令地址`，在最开始时PC为7，也就是函数`P`的起始指令地址。CPU往下执行后发现是一个函数调用，此时把PC修改为被调用函数`Q`的起始指令地址2。直至`Q`执行完毕之后，最后再把PC修改为`P`中调用`Q`时的下一条指令地址9，整个调用过程结束。

现在有一个问题就是对于函数`返回地址`的保存，考虑当有大量函数嵌套调用时，每发生一次函数调用都会产生一个返回地址，并且这些返回地址还要和每次调用进行关联。为了满足这个需求我们需要使用`栈`来存储函数的`返回地址`，当每次发生调用时就将`返回地址`压入到`栈`中，函数执行完之后再把它从栈中弹出到`PC`中。

下面是一个C语言嵌套函数调用的例子，我们分别对它的调用和返回过程进行说明：

```c
void Q() {
    printf("this is Q.\n");
    return;
}

void P() {
    printf("readying to call Q.\n");
    Q();
    return;
}

void main() {
    printf("readying to call P.\n");
    P();
    return;
}
```

## 3.1 调用过程

还是假设代码的`行号`为每条指令的地址，最开始PC为13，也就是`main`函数的第一行代码，程序继续执行到14，发现这里调用了函数`P`，首先将调用`P`处的下一条指令地址15压入栈中，随后把`PC`设为P的起始指令地址7。程序继续执行到8，发现这里调用了函数`Q`，同样先将调用`Q`处的下一条指令地址9压入栈中，然后把PC设为`Q`的起始指令地址2，此时栈中存储了两个`返回地址`分别是9和15。

栈变化过程：

![](images/stack8.png)

## 3.2 返回过程

在函数`Q`执行完之后，函数开始返回，返回时会把栈中之前保存的`返回地址`弹出到PC中，此时栈顶是指令地址9，将它从栈中弹出到PC中，函数成功的返回到`P`中。再待`P`执行完成之后，继续把栈顶的指令地址15弹出到PC中，到最后函数返回到了`main`中，栈也恢复成了发生调用前的样子。

栈变化过程：

![](images/stack9.png)

整套过程可以推广至任意层函数调用以及递归调用，栈完美的保存了函数的返回地址。这里为了举例方便把一行C代码当成一条指令，实际上这里的指令是经过编译后的`机器指令`，那么一行C代码可能会对应多条机器指令，每条机器指令在内存中都会有一个地址。

---

# 第四章：数据传递

> 有时候调用者需要向被调用者`传递参数`，同时被调用者也可能需要向调用者`返回数据`。

## 4.1 参数传递

默认情况下`X64`（英特尔64位）中前6个参数存放在一组约定的寄存器中，其余参数以`从右到左`的顺序压入`堆栈`，因此被调用者可以访问这组寄存器或`堆栈`来获取参数。而在`X86`（英特尔32位）中会直接将所有的参数以`从右到左`的顺序压入堆栈，所以被调用者只需要访问`堆栈`就可以获取参数。

在X64的System V AMD64 ABI中，前6个整数/指针参数依次使用以下寄存器传递：

| 参数顺序 | 寄存器 |
|---------|--------|
| 第1个 | rdi |
| 第2个 | rsi |
| 第3个 | rdx |
| 第4个 | rcx |
| 第5个 | r8 |
| 第6个 | r9 |

另外当被调用函数引用了参数的内存地址，那么这个参数也必须放在栈中，因为寄存器是没有内存地址的。

C语言中参数传递的例子（以`X64`为例）：

```C
void Q(long arg1, long arg2, long arg3, long arg4, long arg5, long arg6, long arg7, long arg8) {
    printf("this is Q.\n");
    return;
}

void main() {
    printf("readying to call Q.\n");
    Q(1, 2, 3, 4 ,5 ,6 ,7 ,8);
    return;
}
```

上面代码中函数`Q`有8个参数，前6个参数通过寄存器传递，多出来的2个参数`arg7`和`arg8`以`从右到左`的顺序压入堆栈，所以这里的压栈顺序是先`arg8`后`arg7`。为了方便绘图所以这里使用了`long`类型，它占8个字节刚好对应图中一个单元格。

压栈过程：

![](images/stack10.png)

## 4.2 返回值

函数最多只会有一个返回值，所以通常就直接放在寄存器中，然后调用者再从这个寄存器中获取返回值。在X64中，返回值存放在`rax`寄存器中。

---

# 第五章：寄存器的保存与恢复

> 在产生`函数调用`时，有可能`调用者`使用了某个寄存器，`被调用者`也使用了这个寄存器并修改了其中的值。如果调用结束后调用者还需要使用先前这个寄存器中的值，此时就会导致`调用者`的状态`遭到破坏`。所以在函数调用时需要对这个寄存器中的值进行保存，同时函数返回时再把它恢复到`调用前的状态`。

由于`栈`这种数据结构具有`记忆功能`，也就是当你将某个元素压入栈中之后，再进行`出栈`此时`出栈`时的元素还是你先前压入栈中的元素。所以通常使用`栈`来对寄存器进行`保存与恢复`。首先将寄存器中的值压入到`栈`中进行保存，然后才能对它们进行修改，最后再将之前保存在`栈`中的值逐个恢复到寄存器中。

下面代码分别把`ax,bx`这两个寄存器保存在栈中：

```c
push(ax);
push(bx);
```

保存过程：

![](images/stack11.png)

把栈中的值逐个恢复到寄存器中：

```c
pop(bx);
pop(ax);
```

恢复过程：

![](images/stack12.png)

这里要注意的是出栈和入栈的顺序是相反的，因为此时`栈顶`是之前`bx`的值，所以在恢复时需要先把`栈顶`的值弹出到`bx`，然后再把下一个值弹出至`ax`，这样就把值与寄存器对应起来了。

## 5.1 寄存器分类

**并不是所有的寄存器都需要`保存与恢复`，根据约定把寄存器中的一部分划分为`被调用者保存`和`调用者保存`：**

在X64 System V ABI中，寄存器的分类如下：

| 类型 | 寄存器 |
|------|--------|
| 被调用者保存 | rbx, rbp, r12, r13, r14, r15 |
| 调用者保存 | rax, rcx, rdx, rsi, rdi, r8, r9, r10, r11 |
| 栈指针 | rsp（特殊，必须保持） |

### 被调用者保存

由`被调用者`来负责这组寄存器的`保存与恢复`。由于任何一个函数都是一个`被调用者`，因为函数总是被调用后才会运行，因此可以得出任何一个函数在修改这组寄存器时都需要对它们进行`保存与恢复`。

例如函数P调用函数Q，在Q被执行时，Q首先将这组寄存器中它需要修改的部分寄存器压入`栈`中进行保存，最后在返回时再由Q负责再把栈中保存的值弹出到这些寄存器中进行恢复。

### 调用者保存

除了`被调用者保存`和`栈指针`（sp）以外的其他寄存器被称为`调用者保存`寄存器。由于任何一个函数都是一个`被调用者`，因此可以得出任何一个函数在修改这组寄存器时都不需要对它们进行`保存与恢复`。

例如函数P调用函数Q，在Q被执行前，P首先将这组寄存器中它不希望在Q返回时`发生改变`的部分寄存器压入`栈`中进行保存，最后Q返回后由P负责把栈中保存的值弹出到这些寄存器中进行恢复。

---

# 第六章：局部变量的存储

> 寄存器和内存都可以用来存放`函数执行时`所需的`数据`。寄存器的存取速度比内存快很多，所以通常会优先把数据存入寄存器中。但是由于寄存器数量有限，因此当寄存器不够用时会将数据存放在`栈`内存中。

**我们可以把`栈指针`（sp）向`栈顶移动`来为函数在栈中分配用于存放`局部数据`的内存空间。**

例如有如下C语言代码：

```c
void main() {
    long foo = 100;
    long bar = 200;
}
```

代码中定义了两个`long`类型变量`foo`和`bar`，我们假设它们都放在`栈`中，由于`long`类型占用8个字节，因此我们需要在栈中分配16个字节的空间。

分配过程（一个单元格8个字节）：

![](images/stack13.png)

最后再把这两个变量分别存入栈中：

![](images/stack14.png)

---

# 第七章：函数栈帧

> 当一个函数在运行时，需要为它在`堆栈`中创建一个`栈帧`（stack frame）用来记录运行时产生的相关信息，因此每个函数在执行前都会创建一个栈帧，在它返回时会销毁该栈帧。

**本节的示意图我们通过颜色区分调用者与被调用者的栈帧，蓝色表示被调用者，绿色表示调用者。**

## 7.1 创建栈帧

通常用一个叫做`栈基址`（bp）的寄存器来保存正在运行函数栈帧的`开始地址`，由于`栈指针`（sp）始终保存的是栈顶的地址，所以`栈指针`保存的也就是正在运行函数栈帧的`结束地址`。

![](images/stack3.png)

> 每次发生函数调用时都要修改`栈基址`（bp）使它保存新栈帧的`开始地址`，这将导致它被覆盖。因此我们可以利用之前讲到的`寄存器的保存与恢复`使用栈来对`栈基址`进行保存与恢复。

在一开始`栈基址`和`栈指针`都分别指向调用者栈帧的`开始地址`和`结束地址`，创建时首先将调用者栈帧的`开始地址`也就是此时的`栈基址`压栈保存，由于`栈基址`是`被调用者保存`寄存器，所以它存放在被调用的栈帧中。

栈变化过程：

![](images/stack18.png)

随后将`栈基址`（bp）修改成此时`栈指针`（sp）的值，使它们都指向同一个位置（下面左图），如果被调用函数还需要栈空间，那么它可以继续把`栈指针`（sp）向低地址移动来分配空间（下面右图），最终`栈基址`和`栈指针`又分别指向了`被调用者`栈帧的`开始地址`和`结束地址`。

栈变化过程：

![](images/stack19.png)

栈帧中存储了函数参数、返回地址、保存的寄存器、局部变量，因此完整的栈结构可能像下面这样：

![](images/stack20.png)

### 栈帧各部分说明

- **函数参数（arguments）**

  在`X64`中如果函数参数超过6个，前6个通过寄存器进行传递，其余参数则通过栈来进行参数传递，当少于等于6个或没有参数时，这个时候该栈帧部分可以忽略。

  在需要通过栈来传递参数时，`调用函数`需要先将参数压入自己的栈帧中，然后`被调用函数`从`调用函数`的栈帧中对参数进行访问。所以图中参数部分在调用函数的栈帧中。

- **返回地址（ret addr）**

  将函数参数压栈之后，需要把调用位置处的下一条指令地址压栈，以便被调用函数执行完之后可以回到原来的位置继续执行，这个地址就是返回地址。

- **保存的寄存器（saved regs）**

  这里存放的是需要`被调用者`来保存的寄存器，例如`旧的栈基址`（old bp）就保存在其中。

- **局部变量（local vars）**

  这个部分是存储在栈中而不是寄存器中的局部变量，如果函数没有局部变量或局部变量都存储在寄存器中，那么该栈帧部分可以忽略。

**如果再次发生函数调用，那就重复整个创建栈帧的过程，因此对于递归函数来说和普通函数也没什么区别。**

> **栈对齐要求**：在X64中，函数调用时栈指针必须16字节对齐（在`call`指令执行前，rsp必须是16的倍数）。这是因为某些SSE指令要求操作数16字节对齐。编译器会自动插入填充（padding）以满足对齐要求，所以有时候你会看到栈帧中有一些未使用的空间。

## 7.2 销毁栈帧

> 在函数返回时会把之前给这个函数创建的栈帧`销毁`，以释放空间。

销毁时先把`栈指针`（sp）移动到此时`栈基址`（bp）的位置，此时`栈指针`和`栈基址`都指向同样的位置。

栈变化过程：

![](images/stack5.png)

现在栈顶刚好是我们在创建栈帧时保存的调用者`栈帧`的`栈基址`，现在把它出栈至`栈基址`（bp），得到下图中的栈结构：

![](images/stack7.png)

到目前为止`被调用者`的栈帧已经被销毁空间得到释放，但是函数的返回步骤并没有完，`调用者`的栈帧中还保存着`返回地址`，此时需要把`返回地址`出栈至`程序计数器`（PC）以恢复到原来的位置继续执行，返回后的栈帧：

![](images/stack6.png)

**C/C++中销毁栈帧并不会清空被销毁栈帧中的数据。**

---

# 第八章：C语言函数栈帧实例

> 我们通过把一段具有函数调用的C语言代码编译成汇编，逐步分析函数栈帧生命周期的完整变化过程。

有如下C语言代码：

```c
long callee(long arg1, long arg2, long arg3, long arg4, long arg5, long arg6, long arg7, long arg8) {
    return arg7 + arg8;
}

int main() {
    long a = 7;
    long b = 8;
    callee(1, 2, 3, 4 ,5 ,6, a, b);
    return 0;
}
```

代码中`callee`函数有8个参数分别是`arg1~arg8`，它返回`arg7`和`arg8`相加后的结果。由于我们的代码是运行在`X64`的机器上，所以`arg1~arg6`会通过寄存器来传递，`arg7`和`arg8`通过栈来传递。`main`中定义了两个局部变量`a`和`b`，它对`callee`发起调用，局部变量`a,b`分别对应`callee`函数的`arg7,arg8`。

将上面C语言代码编译成汇编，把由编译器产生的其他与我们分析函数栈帧不相关的指令删除，得到如下指令（根据编译器版本以及操作系统的不同编译出的汇编指令会有所差异，这里使用的编译器和操作系统分别是`gcc9.0`和`ubuntu 20.04 x-64`）：

```ASM
callee:
    pushq	%rbp
    movq	%rsp, %rbp
    movq	%rdi, -8(%rbp)
    movq	%rsi, -16(%rbp)
    movq	%rdx, -24(%rbp)
    movq	%rcx, -32(%rbp)
    movq	%r8, -40(%rbp)
    movq	%r9, -48(%rbp)
    movq	16(%rbp), %rdx
    movq	24(%rbp), %rax
    addq	%rdx, %rax
    popq	%rbp
    ret
main:
    pushq	%rbp
    movq	%rsp, %rbp
    subq	$16, %rsp
    movq	$7, -16(%rbp)
    movq	$8, -8(%rbp)
    pushq	-8(%rbp)
    pushq	-16(%rbp)
    movl	$6, %r9d
    movl	$5, %r8d
    movl	$4, %ecx
    movl	$3, %edx
    movl	$2, %esi
    movl	$1, %edi
    call	callee
    addq	$16, %rsp
    movl	$0, %eax
    leave
    ret
```

指令中的`callee:`和`main:`表示的是为它下面的指令取一个名字，可以理解为函数名。

**在`X64`中`栈指针`和`栈基址`分别叫`rsp,rbp`。**

## 8.1 创建main的栈帧

我们逐步分析这些指令对堆栈的影响，首先是`main`的前两行指令：

```asm
pushq	%rbp
movq	%rsp, %rbp
```

实际上`main`函数是被系统内一个叫做`_start`的函数所调用，所以第1条指令将`调用者`_start的`栈基址`压栈保存，第2条指令移动`栈基址`使它指向和`栈指针`同样的位置。

栈变化过程（在一开始我们`栈指针`和`栈基址`指向`_start`的栈帧，这里没有画出`_start`的栈帧也就没有标注它们）：

![](images/stack22.png)

## 8.2 初始化局部变量并准备参数

初始化局部变量并准备`callee`的后两个参数：

```asm
subq	$16, %rsp
movq	$7, -16(%rbp)
movq	$8, -8(%rbp)
pushq	-8(%rbp)
pushq	-16(%rbp)
```

第1条指令中的`subq`是减法指令，这里用于把`栈指针`减去16，使它向低地址移动来给局部变量`a,b`分配16字节的空间（long占8个字节）。

第2~3条指令中的`movq`是数据移动指令，在这里它通过对`栈基址`进行适当偏移来对`a,b`赋值。例如`movq $7, -16(%rbp)`表示把7放到相对于`栈基址`-16的内存中。下图中可以看到这两条指令执行完以后`-16`和`-8`的位置刚好放置了变量`a,b`。

第4~5条指令把栈帧中`a,b`的值复制一份然后把它们压栈，这是为了准备函数`callee`的后2个参数`arg7`与`arg8`。

栈变化过程（图中右侧的数字表示基于`栈基址`的偏移量，每个格子8字节，由于栈空间是向低地址发展的，所以相对于`栈基址`上面内存的偏移量是负的）：

![](images/stack23.png)

## 8.3 把参数存放在寄存器中

把`callee`的前6个参数`arg1~arg6`存放在寄存器中：

```asm
movl	$6, %r9d
movl	$5, %r8d
movl	$4, %ecx
movl	$3, %edx
movl	$2, %esi
movl	$1, %edi
```

## 8.4 调用callee

开始调用`callee`：

```asm
call	callee
```

这条指令对应了两个操作，首先将它下面一条指令的地址也就是`addq $16, %rsp`的地址（返回地址）压入栈中，随后修改`程序计数器`（PC）为`callee`的第一条指令的地址，最后CPU就从`callee`处开始执行。

这条指令执行后的栈：

![](images/stack24.png)

## 8.5 创建callee的栈帧

现在CPU从`callee`开始执行：

```asm
pushq	%rbp
movq	%rsp, %rbp
```

先压入`main`栈帧的`栈基址`，然后移动`栈基址`使它指向和`栈指针`同样的位置。此时产生了`callee`的栈帧：

第2条指令使`栈基址`发生了改变，相应的右图中基于`栈基址`的偏移量也需要发生变化（由于栈空间是向低地址发展的，所以相对于`栈基址`下面内存的偏移量是正的）：

![](images/stack25.png)

## 8.6 复制参数到栈帧中

复制前6个参数到栈帧中：

```asm
movq	%rdi, -8(%rbp)
movq	%rsi, -16(%rbp)
movq	%rdx, -24(%rbp)
movq	%rcx, -32(%rbp)
movq	%r8, -40(%rbp)
movq	%r9, -48(%rbp)
```

这6个寄存器`rdi,rsi,rdx,rcx,r8,r9`分别存放了`callee`的前6个参数，现在将它们从寄存器中复制到`callee`自己的栈帧中。编译器这样做有几个原因：(1) 函数体内可能需要获取参数的地址（如`&arg1`），而寄存器没有内存地址；(2) 寄存器数量有限，复杂函数需要腾出寄存器给其他计算使用；(3) 这里未启用编译器优化（`-O0`），启用优化后这些冗余操作会被消除。

执行之后的栈结构：

![](images/stack26.png)

执行到这里奇怪的事情发生了，`栈指针`并没有继续向低地址移动，让它指向栈顶的位置。这其实与X64 ABI中的**红区（Red Zone）**概念有关。

> **红区（Red Zone）**：在X64 System V ABI中，栈指针下方的128字节被称为"红区"。叶子函数（不调用其他函数的函数）可以使用这块区域存储临时数据，而无需移动栈指针。这样可以节省`subq`和`addq`指令，提高效率。但如果函数调用了其他函数，红区的数据可能会被覆盖，所以只有叶子函数才能使用红区。

由于`callee`没有再继续调用其他任何函数（是一个叶子函数），因此可以直接使用红区而无需修改`栈指针`。

## 8.7 执行相加

执行相加：

```asm
movq    16(%rbp), %rdx
movq	24(%rbp), %rax
addq	%rdx, %rax
```

将`arg7`与`arg8`相加，然后把结果放在`rax`寄存器，`main`函数可以访问`rax`寄存器来获取返回值，以此来达到函数返回值传递的目的。

## 8.8 返回到main

返回到`main`：

```asm
popq	%rbp
ret
```

恢复`栈基址`并跳转到返回地址处开始继续执行。

栈变化过程：

![](images/stack27.png)

## 8.9 返回到_start

返回到`_start`：

```asm
addq	$16, %rsp
movl	$0, %eax
leave
ret
```

第1条指令中的`addq`是加法指令，这里用于把`栈指针`加上16，使它向高地址移动以此来释放`arg7,arg8`的内存。通过这一步可以发现，函数执行完后会立马释放参数的栈内存。

第2条指令把`main`的返回值0放入到`eax`寄存器中。

第3条指令`leave`隐含执行了两个操作，它等价与下面两条指令：

```asm
movq	%rbp, %rsp
popq	%rbp
```

先修改`栈指针`使它与`栈基址`指向同样的位置，这一步主要用于释放局部空间，然后恢复`栈基址`。此时`栈指针`和`栈基址`就分别指向了`_start`的栈帧。

到这里我们发现`main`和`callee`的返回过程不一样，这是由于在`callee`一开始没有通过`subq`指令修改`栈指针`来分配局部空间，所以返回的时候不需要通过`leave`指令来恢复`栈指针`。由此我们可以得出一个结论：如果某个函数调用了其他函数和没有调用其他函数，它们在返回时的过程有略微的不一致。

第4条指令`ret`使CPU返回到`_start`中去执行，最后一切又恢复了平静。

栈变化过程：

![](images/stack28.png)

**最后我们发现数据仍然还保存在栈中，因为释放栈空间并不会修改里面的数据，只是对`栈指针`和`栈基址`做了移动。**

---

# 第九章：栈帧内存复用

这是一个C语言的例子：

```c
void init_array() {
    int arr[10];
    for (int i = 0; i < 10; ++i) {
        arr[i] = i;
    }
}

void print_array() {
    int arr[10];
    for (int i = 0; i < 10; ++i) {
       printf("%d\t", arr[i]);
    }
}

int main() {
    init_array();
    print_array();
}
```

代码中`init_array`和`print_array`各自有一个长度为10的局部数组`arr`。`init_array`把它内部的`arr`初始化成0~9，print_array把它内部的`arr`遍历输出到控制台，然后在`main`函数中对它们进行调用。

`print_array`执行后输出到控制台：

```bash
0	1	2	3	4	5	6	7	8	9
```

结果有点让人疑惑，似乎这两个函数有着某种关系。

现在取消对`init_array`的调用，再看下结果：

```bash
177988	32765	5497827	21857	2157688	32518	9257904	21857	0	0
```

这次输出了随机值，因为C/C++并不会初始化内存中的值，这些值都是上一次使用这些内存的程序留下的。

对比两次结果发现`init_array`确实对`print_array`中的数组`arr`产生了影响。`init_array`和`print_array`中的`arr`看起来都各自独立，为什么会出现这种情况？

来看下这两个函数各自在返回前的栈帧结构：

![](images/stack29.png)

可以发现它们的栈帧结构和大小完全一样。`init_array`执行完之后它的栈帧被销毁，但是原来的值还在内存中。当`print_array`执行时继续给它分配了同一块内存且栈帧结构也一样，这样就把`init_array`在内存中遗留的数据拿到了。

我们对代码稍作修改，让这两个函数都把各自`arr`在内存中的地址输出到控制台：

```c
void init_array() {
    int arr[10];
    printf("%p\n", arr);
}

void print_array() {
    int arr[10];
    printf("%p", arr);
}

int main() {
    init_array();
    print_array();
}
```

控制台结果：

```bash
0x7ffd2aaf3ff0
0x7ffd2aaf3ff0
```

结果再一次印证了这两个`arr`被放到了是同一块栈内存中。所以`print_array`输出了原先在`init_array`中`arr`的值。

---

# 第十章：手动修改栈帧数据

> 我们可以获取某一局部变量在内存中的地址，然后对该地址进行偏移来修改栈中其他位置的数据。只要我们对栈结构足够了解，就可以修改你想修改的数据。

## 10.1 修改局部存储

> 由于C/C++不检查数组越界访问，因此我们可以借助这一特点来修改栈帧中的数据。

有如下代码：

```c
int main() {
    long foo = 10;
    long arr[2] = {1, 2};
    arr[-1] = 20;
    printf("foo is %ld", foo);
    return 0;
}
```

代码中数组`arr`和变量`foo`它们在栈中是连续存放的：

![](images/stack30.png)

图中还发现变量`foo`放在了更低的地址上，所以在修改`arr[-1]`时也是修改变量`foo`。

代码输出到控制台中的结果：

```bash
foo is 20
```

### Stack Canary

这个例子的栈帧最底部多了一个`canary`（译为金丝雀），它用来防止栈溢出攻击。在进入函数时会先往`返回地址`的上面放置一个任意值，然后在返回时检查这个值是否有被修改，如果被修改就说明栈帧中其他数据也可能被修改过，然后触发相关异常。这个值就叫`canary`。

只有在函数内有指针操作时，编译器才会生成`canary`相关指令。我们这里使用了数组，数组操作在C/C++中其实也是指针操作，所以这里生成了`canary`。

## 10.2 修改返回地址

> 同样的方式我们也可以对一个内存地址进行适当偏移来修改函数的返回地址，从而控制函数返回路径。

有如下代码：

```c
void bar() {
    printf("This is bar!\n");
}

void foo() {
    printf("This is foo!\n");
    long arr[2] = {1, 2};
    arr[5] = bar;
}

int main() {
    foo();
    return 0;
}
```

这个例子中在数组`arr[5]`的位置存放了返回地址，至于为什么是5，我们先来看下在`foo`返回前的栈帧结构（绿色是main的栈帧，蓝色是foo的栈帧）：

![](images/stack31.png)

现在我们从`arr[0]`往下数，刚好在`arr[5]`的位置放置了函数返回地址，我们把它修改成函数`bar`的地址（C/C++中函数名表示函数第一条指令的地址）然后执行，于是得到如下控制台结果：

```bash
This is foo!
This is bar!
段错误 (核心已转储)
```

结果如我们所愿这里成功跳转到了`bar`，但也收获了一个`段错误`。为什么会发生这个`段错误`呢？我们继续看下在`bar`运行前后的栈帧变化（绿色是main的栈帧，蓝色是bar的栈帧）：

![](images/stack32.png)

上面左图是在`ret`指令执行前的栈帧状态，这个时候`栈指针`和`栈基址`已经恢复到调用`foo`前的状态，右图是在`ret`指令执行后，此时`bar addr`已经被出栈，随后跳转到`bar`去执行，`bar`也创建了自己的栈帧。这个时候我们想像一下，当`bar`返回时会发生什么？显然它会把`_start rbp`做为`返回地址`，`_start rbp`不是一个指令的地址，当CPU把它当成一个指令地址去寻找指令时，就发生了`段错误`。

**这两个例子中我们都修改了栈帧数据，但是并没有异常发生，`canary`好像没有起到作用。之所以没有触发异常是因为我跳过了`canary`没有修改它，`canary`可以防止修改连续的一段空间，如果这段空间刚好有`canary`，就会触发异常。**

**这两个例子也说明了数组越界访问可能导致非常严重的bug。**

---

# 第十一章：总结

> 到目前为止我们已经掌握了函数调用的所有细节，现在我们需要利用这些知识来解答一些与函数相关的问题。

## 为什么尽量用循环来代替递归调用？

每一次函数调用都需要初始化和销毁栈帧，因此会带来额外的开销。同时当递归次数过多时，会导致栈内存耗尽，最终出现栈溢出。

## 为什么内联（inline）函数效率高？

内联函数跟普通的函数不一样，但是对于开发者而言你几乎可以使用和普通函数一样的方式去对待内联函数。在编译器实际编译出的指令中，只是把内联函数的指令copy到调用者的函数中，因此也就不会为它初始化栈帧。这样避免了栈帧所带来的开销，使用内联函数可以提升执行效率。

## 为什么静态变量在函数返回后不会被释放？

这是因为静态变量根本不在堆栈这块内存区域中，它存放在一个叫做静态区的地方，所以函数返回时销毁的是栈内存，并不会影响静态区。

## 什么是栈溢出攻击？

在上一节有讲到手动修改函数的返回地址，试想一下如果这个地址被攻击者修改成他自己指令的地址会导致什么后果？此时在函数返回时就会成功转而去执行攻击者的代码。这是一种很古老的攻击方式，现在已经有很多保护方式，例如stack canary、栈数据不可执行、随机化内存空间布局。

## C/C++数组越界访问的危害？

C/C++并不检查数组越界访问，这将导致你越界访问的那段内存可能存放着相邻的其他变量，甚至是函数返回地址等重要数据。如果你还对其进行了修改，后果也很难想象，通常数组越界的bug也很难调试。

## 为什么不能返回局部变量的指针？

局部变量存储在栈帧中，函数返回后栈帧被销毁，该内存可能被后续函数调用覆盖。返回的指针指向的是一块已经无效的内存，访问它是未定义行为（Undefined Behavior），可能导致程序崩溃或产生不可预期的结果。

## 什么是尾递归优化？

当递归调用是函数的最后一个操作时，编译器可以复用当前栈帧而不是创建新栈帧，从而将递归转换为循环，避免栈溢出。这种优化称为尾递归优化（Tail Call Optimization）。需要使用`-O2`及以上优化级别才会启用。

## 栈的大小限制是多少？

Linux默认栈大小通常是8MB（可通过`ulimit -s`查看和修改），Windows默认是1MB。栈大小是有限的，这就是为什么深度递归或分配过大的局部数组会导致栈溢出（Stack Overflow）。

---

*完*
